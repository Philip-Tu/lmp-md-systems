#!/usr/bin/env python

import numpy as np
import re as re
import os as os
import matplotlib.pyplot as plt


def count_total_lines(file_path):
    """ Count total number of lines in the file specified.

    @param FILE_PATH: A string representing the path from the CWD of this notebook to the file to be counted.

    @return An integer denoting the total number of lines written in the file FILE_PATH.
    """
    file = open(file_path, 'r')
    line_count = 0
    parsed_line = file.readline()
    while (parsed_line != ''):
        line_count += 1
        parsed_line = file.readline()
    file.close()
    return line_count


def read_rdf_arrays(file_path):
    """ Read RDF data from .rdf file into numpy arrays. It is assumed that there are four columns
    in the .rdf file, that the same file records time-averaged, cumulative RDF data, and that it is 
    of proper format generated using lammps fix ave/time function.

    @param FILE_PATH: A string representing the path from the CWD of this notebook to the .rdf
        file to be parsed.

    @return 2 numpy arrays ordered by:
        1) r values corresponding to the center of each bin
        2) radial distribution function g(r) densities
    """

    file = open(file_path, 'r')

    r_lst = []
    rdf_lst = []

    curr_ln = file.readline()
    start_read = False

    while curr_ln != '':
        curr_ln = curr_ln.rstrip('\n')
        curr_ln_split = re.split(r'\s', curr_ln)

        if len(curr_ln_split) == 4:
            start_read = True

        if start_read:
            r_lst.append(float(curr_ln_split[1]))
            rdf_lst.append(float(curr_ln_split[2]))

        curr_ln = file.readline()

    file.close()

    r_arr = np.array(r_lst)
    rdf_arr = np.array(rdf_lst)

    return r_arr, rdf_arr

def make_overlaid_plots(paths, labels, title, save_path = ''):
    """ Generate ONE properly formatted rdf plot; overlaid rdf curves are readily available and the final plot can
    be saved to disk.

    Args:
        paths (iterable of strings): paths from the current notebook directory to the .rdf files to be parsed in order.
        labels (iterable of strings): legend labels for each rdf curve whose path is listed in paths; should be ordered
        in correspondence and equal in length to paths.
        title (string): title of the rdf plot.
        save_path (string): path indicating the file to which the generated figure should be saved on disk; no figure will
        be saved if no path is entered (i.e. the default, an empty string). Should end in '.png'

    Returns:
        NULL. The rdf plot will be output to screen, or even saved to disk.
    """
    plt.figure()
    plt.xlabel("r")
    plt.ylabel("g(r)")
    plt.title(title)
    plt.axhline(y=1, ls='--', c='k')

    for i in range(len(paths)):
        file_path = paths[i]
        label = labels[i]
        r_arr, rdf_arr = read_rdf_arrays(file_path)
        plt.plot(r_arr, rdf_arr, label = label)

    plt.legend()

    if save_path != '':
        plt.savefig(save_path, dpi=400, bbox_inches='tight')


def make_rdf_from_arr(rdf_arr, plot_title, label=""):
    """ Generate a RDF plot using RDF data passed in as an argument. This function (so far) is designed
    solely for data visualization (i.e. resulting figures will not be exported as .png high quality images)

    @param RDF_ARR: A 2-D array consisted of 4 columns of RDF data; This array should closely
        follow the format of the array generated by c_rdf_file_to_array.
    @param PLOT_TITLE: A string specifying the title of the RDF plot.
    @param LABEL: A string encoding the legend label that the RDF plot should be labeled with; defaults to no label.

    @return A single RDF line plot generated using RDF_ARR with title PLOT_TITLE.
    """
    # Extract compute_rdf parameters
    num_bin = len(rdf_arr)
    bin_width = rdf_arr[0][1] * 2

    # rdf_cutoff = num_bin * bin_width    # cutoff distance for c_rdf

    # Plot rdf as a line plot
    rdf_r = np.empty(num_bin)
    rdf_density = np.empty(num_bin)

    for i in range(num_bin):
        rdf_r[i] = rdf_arr[i][1]
        rdf_density[i] = rdf_arr[i][2]

    if label != "":
        plt.plot(rdf_r, rdf_density, label=label)
        plt.legend()
    else:
        plt.plot(rdf_r, rdf_density)
    plt.xlabel("r")
    plt.ylabel("g(r)")
    plt.title(plot_title)
    plt.axhline(y=1, ls='--', c='k')
    plt.show()

def c_rdf_file_to_array(file_path):
    """ Read RDF data from .rdf file into a numpy array. It is assumed that there are four columns
    in the .rdf file, that the same file records time-averaged, cumulative RDF data, and that data
    entries start on Line 5 of the file.
    @param FILE_PATH: A string representing the path from the CWD of this notebook to the .rdf
        file to be parsed.
    @return A 2-dimensional array with rows representing rdf bins and columns representing bin label,
        bin center (r) value, radial distribution g(r), and coordination number, respectively.
    """
    num_lines = count_total_lines(file_path)

    file = open(file_path, 'r')

    num_rows = num_lines - 4
    arr = np.empty([num_rows, 4])

    for i in range(1, 5):
        file.readline()

    for i in range(5, num_lines + 1):
        row_str = file.readline()
        row_str = row_str.rstrip('\n')
        row_str_split = re.split(r'\s', row_str)
        for j in range(4):
            arr[i - 5][j] = float(row_str_split[j])

    file.close()
    return arr


def plot_mult_rdf(var, var_values, sim_file_name, rdf_file_path, extra_args=[]):
    """ Generate RDF calculations using LAMMPS by varying a specified variable over a specified
    value set. This is an encapsulating function that will edit the variable value in the LAMMPS input
    file, run the simulation, read in RDF data, and plot the overlaid RDF, while finally exporting the
    subsequent plot as a .png image to ../examples/active/figures directory. Extra functionalities are
    available.

    @param VAR: A string denoting the simulation parameter to be changed between simulation runs.
    @param VAR_VALUES: A tuple/array specifying the set of values VAR should take between each simulation run.
    @param SIM_FILE_NAME: A string representing the name of the LAMMPS .in file that needs to be modified;
        should be in the format <file_name>.in
    @param RDF_FILE_PATH: A string representing the path from this notebook CWD to the LAMMPS .rdf file that
        is output from each simulation run and containing RDF calculation data used to plot radial distributions.
    ##########################################################################################################
    @param EXTRA_ARGS: An array containing any extra argument that is needed to employ the extended functionality
        of this function. Defaults to an empty array, denoting that only basic functionality is used. The extra
        functionalities include:
            1) obtain temperatures of the passive WCA particles computed during equilibrated runs and write them
            to a designated file along with the corresponding f_active's. Arguments include: Use simultaneously
            with f_active.........
            [boolean, lammp_output_path, wca_temp_file_path]
    ##########################################################################################################

    @return Multiple RDF line plots generated using RDF data obtained for each simulation run.
    """
    # declare variables for extra functionalities
    tmps = []

    # pick out variables that are kept constant between runs
    full_param_lst = ["rhoactive", "rhopassive", "gamma", "f_active"]
    param_lst = []
    for p in full_param_lst:
        if p != var:
            param_lst = param_lst + [p]

    cwd = os.getcwd()
    # directory in which LAMMPS .in file is located
    sim_dir = cwd + '/../examples/active'

    params = {}
    for curr_val in var_values:
        # rewrite the .in file with new VAR value
        sim_file_path = "../examples/active/" + sim_file_name
        sim_file = open(sim_file_path, 'r')
        lines = sim_file.readlines()
        sim_file.close()
        sim_file = open(sim_file_path, 'w')
        for line in lines:
            cleaned_line = line.rstrip('\n')
            line_split = re.split(r'\s+', cleaned_line)
            if line_split[0] == 'variable':
                variable = line_split[1]
                if variable == var:
                    sim_file.write("variable " + var +
                                   " equal " + str(curr_val) + "\n")
                else:
                    if variable in param_lst:
                        params[variable] = line_split[3]
                    sim_file.write(line)
            else:
                sim_file.write(line)
        sim_file.close()

        # run simulation
        os.chdir(sim_dir)
        os.system('mpirun -np 4 ~/Desktop/lammps/build/lmp -in ' + sim_file_name)
        os.chdir(cwd)

        # execute extra functionalities BETWEEN runs
        if extra_args:
            lmp_temp_out_file = extra_args[0][1]
            temp = read_passive_temp(lmp_temp_out_file)
            tmps = tmps + [temp]

        # plot rdf of the current simulation run
        total_line_count = count_total_lines(rdf_file_path)
        rdf_arr = c_rdf_file_to_array(rdf_file_path)
        num_bin = len(rdf_arr)
        bin_width = rdf_arr[0][1] * 2
        rdf_r = np.empty(num_bin)
        rdf_density = np.empty(num_bin)

        for i in range(num_bin):
            rdf_r[i] = rdf_arr[i][1]
            rdf_density[i] = rdf_arr[i][2]

        plt.plot(rdf_r, rdf_density, label=var + ": " + str(curr_val))

    # execute extra functionalities AFTER runs
    if extra_args:
        wca_temp_input_file = extra_args[0][2]
        force_temp = {}
        for i in range(len(var_values)):
            force_temp[var_values[i]] = tmps[i]
        write_force_temp_pair(force_temp, wca_temp_input_file)

    # add plot features and export plot
    var_vals = ""
    for parameter in param_lst:
        var_vals += parameter + "=" + params[parameter] + " "
    var_vals = var_vals.rstrip()
    plot_title = "RDF of Active Dumbbells with " + var_vals
    plt.title(plot_title)
    plt.xlabel("r")
    plt.ylabel("g(r)")
    plt.legend()
    plt.axhline(y=1, ls='--', c='k')
    # plt.savefig("../examples/active/figures/" + var_vals +
    #             ".png", dpi=400, bbox_inches='tight')
    plt.show()


def read_passive_temp(temp_file_path):
    """Assume scalar output"""
    file = open(temp_file_path, 'r')
    file_rows = file.readlines()
    temp_row = file_rows[2]
    temp_row = temp_row.rstrip('\n')
    row_split = re.split(r'\s', temp_row)
    temp = float(row_split[1])
    file.close()

    return temp


def write_force_temp_pair(force_temp_dict, force_temp_file_path):
    file = open(force_temp_file_path, 'w')
    keys = force_temp_dict.keys()
    for key in keys:
        value = force_temp_dict[key]
        line = str(key) + " " + str(value) + "\n"
        file.write(line)
    file.close()
