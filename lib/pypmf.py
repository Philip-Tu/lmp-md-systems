#!/usr/bin/env python

import numpy as np
import re
import os
import matplotlib.pyplot as plt
import math
import sys
sys.path.append('../lib')
import pyrdf


def compare_rdf_pmf(num_bin, cutoff, pmf_distr, paths, plot_title, png_name, y_lim, savefig=True):
    """ Compare graphically a PMF distribution generated through simulation and post-processing with one that is generated
    through applying the derivative form of reversible work theorem on a RDF; the RWT calculation is performed within this
    function.

    Args:
        num_bin (int): the desired number of bins for either distribution.
        cutoff (float): the upperbound (in appropriate units) of the histogram/of the last bin.
        pmf_distr (1-D array): the histogram/distribution of any type of force (parallel or tranverse) that
            has num_bin many bins.
        paths (str-str dict): the paths to files/directories from the working directory of "jupyter".
            The paths should consist of:
                "rdf_file": file containing rdf data output from LAMMPS
                "temp_file": file with averaged temperature of simulation bath
                "fig_dir": directory in which figure generated by this function should be saved.
        plot_title (str): title label of the generated plot.
        png_name (str): name of the .png file containing the exported/saved plot.
        y_lim (1-D array): formatted as the desired [lowerbound, upperbound] of the y-axis of the plot.
        savefig (bool): determines whether or not the generated plot is saved to disk. Default to True.

    Returns:
        NULL: the comparison plot is exported into the directory fig_dir and nothing is returned.
    """
    rdf_file = paths["rdf_file"]
    temp_file = paths["temp_file"]
    fig_dir = paths["fig_dir"]

    T = pyrdf.read_passive_temp(temp_file)
    bin_width = cutoff/num_bin

    rdf_arr = pyrdf.c_rdf_file_to_array(rdf_file)
    rdf_density = np.empty(num_bin)
    for i in range(num_bin):
        rdf_density[i] = rdf_arr[i][2]

    # reversible work theorem (RWT)
    pmf_rwt = np.gradient(np.log(rdf_density), bin_width) * T
    
    x_ax = np.linspace(0, cutoff, num_bin)

    plt.figure()
    plt.plot(x_ax, pmf_distr)
    plt.plot(x_ax, pmf_rwt)
    plt.ylim(y_lim[0], y_lim[1])
    plt.title(plot_title)
    plt.xlabel('$|r_{1}-r_{2}|$')
    plt.legend([r'PMF: $\left<\frac{d}{dr_{1}}U\right>_{r_{1},r_{2}}$',
                r'RDF: $k_{B}T\frac{d}{dr_{1}}(ln\hspace{0.2}g(r_{1},r_{2}))$'])
    plt.axhline(y = 0, ls = '--', c = 'k')
    if savefig:
        plt.savefig(fig_dir + '/' + png_name + '.png', dpi=400, bbox_inches='tight')


def calc_pmf_distr(file_path, num_bin, cutoff, lx, ly, mol=False):
    """ An encapsulating function that calculates and plots the potential of mean force (PMF) between a pair of
    passive (WCA) particles suspended in a bath of active dumbbells across their intermolecular distance in the
    interparticle/parallel as well as the transverse directions. Sign convention used is: 1) a positive interparticle
    force is effective "repulsion" and 2) a positive transverse force represents effective "rotation" in the
    counterclockwise direction. This function is capable of both reading and processing data to generate desired
    plots.

    @param FILE_PATH: A string representing the path from the CWD of this notebook to the position-force file to be parsed.
    @param NUM_BIN: An integer value denoting the desired number of bins.
    @param CUTOFF: A numerical value denoting the upperbound (in appropriate units) of the histogram/of the last bin.
    @param LX: Length of the simulation box in x direction.
    @param LY: Length of the simulation box in y direction.
    @param MOL: A boolean indicating whether or not the subject of the calculated distribution are molecules (as opposed to
        individual atoms/particles). Default to False.

    @return: Two 1-D arrays that bins parallel and tranverse forces, respectively, as a function of distance r that is
    ready to be plotted using matplotlib. The distribution(s) will be displayed but not saved for convenience.

    Args:
        file_path (TYPE): Description
        num_bin (TYPE): Description
        cutoff (TYPE): Description
        lx (TYPE): Description
        ly (TYPE): Description

    Returns:
        TYPE: Description
    """
    paral_dict = {}
    trans_dict = {}

    data_arr = read_pos_force(file_path)
    for i in range(len(data_arr)):
        one_bins = bin_by_dist(num_bin, cutoff, data_arr[i], lx, ly, mol)
        for key in one_bins.keys():
            vals = one_bins[key]
            for force_pair in vals:
                if key not in paral_dict:
                    paral_dict[key] = [force_pair[0]]
                else:
                    temp = paral_dict[key]
                    temp.append(force_pair[0])
                    paral_dict[key] = temp
                if key not in trans_dict:
                    trans_dict[key] = [force_pair[1]]
                else:
                    temp = trans_dict[key]
                    temp.append(force_pair[1])
                    trans_dict[key] = temp

    paral_arr = np.zeros(num_bin)
    trans_arr = np.zeros(num_bin)

    for bin_label in range(num_bin):
        if bin_label in paral_dict:
            arrp = paral_dict[bin_label]
            fp_avg = np.average(arrp)
            paral_arr[bin_label] = fp_avg
        if bin_label in trans_dict:
            arrt = trans_dict[bin_label]
            ft_avg = np.average(arrt)
            trans_arr[bin_label] = ft_avg

    # make and output plots for parallel and tranverse forces but does NOT save them
    x_ax = np.linspace(0, cutoff, num_bin)
    plt.figure(0)
    plt.plot(x_ax, paral_arr)
    plt.figure(1)
    plt.plot(x_ax, trans_arr)

    return paral_arr, trans_arr


def read_pos_force(file_path):
    """ Read data on the positions of and forces on passive particles in a simulated active dumbbell system. Format
    of the file to be read is strictly assumed to follow that generated by LAMMPS' 'dump custom' command.

    @param FILE_PATH: A string representing the path from the CWD of this notebook to the file to be parsed.

    @return: An appropriate 3-D array with dimensions 1, 2, 3 delineating each timestep, particle, and data
    parameter [(mol), x, y, fx, fy], respectively
    """
    final_arr = []
    atom_lst = []

    file = open(file_path, 'r')
    next_line = file.readline()
    while next_line != '':
        if next_line == 'ITEM: TIMESTEP\n':
            if atom_lst:
                final_arr.append(atom_lst)
                atom_lst = []
            for i in range(8):
                file.readline()
            next_line = file.readline()
        else:
            data = next_line.rstrip('\n').rstrip()
            data_split = re.split(r'\s', data)
            data_float = []
            for s in data_split:
                data_float.append(float(s))
            atom_lst.append(data_float)
            next_line = file.readline()
    if atom_lst:
        final_arr.append(atom_lst)
    file.close()

    return final_arr


def bin_by_dist(num_bin, cutoff, arr, lx, ly, mol):
    """ Bin each possible passive-particle pair given by ARR according to its minimum-image-convention Euclidean
    distance. Pair parameters such as interparticle and transverse forces are calculated.

    @param NUM_BIN: An integer value denoting the desired number of bins.
    @param CUTOFF: A numerical value denoting the upperbound (in appropriate units) of the histogram/of the last bin.
    @param ARR: A 2-D array with dimension 1 separating each passive particle and 2 separating each data parameter in
    the format of [x, y, fx, fy]. This array should correspond to the second and third dimensions of the 3-D array
    returned by the function READ_POS_FORCE.
    @param LX: Length of the simulation box in x direction.
    @param LY: Length of the simulation box in y direction.
    @param MOL: A boolean indicating whether or not the subject of the calculated distribution are molecules (as opposed to
        individual atoms/particles), which affects output lammps file format and force calculations.

    @return: A dictionary with the keys representing the integer bin label (from 0 to NUM_BIN-1) and the corresponding
    values being 2-D arrays with dimension 1 separating each pair in that particular bin and dimension 2 being
    [interparticle, transverse] forces.
    """
    bins = {}
    bin_width = cutoff / num_bin

    for index1 in range(len(arr) - 1):
        p1 = arr[index1]
        if mol:
            mol_id1 = p1[0]
            p1 = p1[1:]
        for index2 in range(index1 + 1, len(arr)):
            p2 = arr[index2]
            if mol:
                mol_id2 = p2[0]
                p2 = p2[1:]
            if not mol or (mol and mol_id1 != mol_id2):
                dist_data = calc_min_dist(p1, p2, lx, ly)
                dist = dist_data[0]
                if dist <= cutoff:
                    bin_label = int(dist // bin_width)
                    dx_min = dist_data[1]
                    dy_min = dist_data[2]
                    forces = calc_forces(p1, p2, dx_min, dy_min)
                    if bin_label in bins:
                        temp = bins[bin_label]
                        temp.append(forces)
                        bins[bin_label] = temp
                    else:
                        bins[bin_label] = [forces]

    return bins


def calc_min_dist(p1, p2, lx, ly):
    """ Calculate the Euclidean distance between two particles using minimum image convention.

    @param P1: An array with format [x, y, fx, fy] for the first particle.
    @param P2: An array with format [x, y, fx, fy] for the second particle.
    @param LX: Length of the simulation box in x direction.
    @param LY: Length of the simulation box in y direction.

    @return: An array [dist_min, dx_min, dy_min] between the two particles (in appropriate units).

    Reference: ResearchGate "Efficient Coding of the Minimum Image Convention"
    """
    x1 = p1[0]
    x2 = p2[0]
    y1 = p1[1]
    y2 = p2[1]
    dx = x1 - x2
    dy = y1 - y2
    lx2 = 0.5 * lx
    ly2 = 0.5 * ly
    kx = int(dx / lx2)
    ky = int(dy / ly2)
    dx_min = dx - kx * lx
    dy_min = dy - ky * ly
    dist_min = ((dx_min**2) + (dy_min**2))**0.5

    return [dist_min, dx_min, dy_min]


def calc_forces(p1, p2, dx_min, dy_min):
    """ Calculate the interparticle and transverse forces between a pair of particles. The convention used for the
    forces in each direction is: 1) a positive interparticle force is effective "repulsion" and 2) a positive
    transverse force represents effective "rotation" in the counterclockwise direction.

    @param P1: An array with format [x, y, fx, fy] for the first particle.
    @param P2: An array with format [x, y, fx, fy] for the second particle.
    @param DX_MIN: Calculated distance in the x direction between the two particles using minimum image convention.
    @param DY_MIN: Calculated distance in the y direction between the two particles using minimum image convention.

    @return: An array in the form of [interparticle, transverse] forces.

    Reference: Wikipedia "Rotation of axes"
    """
    fx1 = p1[2]
    fy1 = p1[3]
    fx2 = p2[2]
    fy2 = p2[3]

    # special case: when the two particles are perfectly vertically aligned
    if dx_min == 0:
        if dy_min > 0:
            finter = fy1 - fy2
            ftrans = -fx1 + fx2
        else:
            finter = -fy1 + fy2
            ftrans = fx1 - fx2
        return [finter, ftrans]

    # general cases
    angle_abs = math.atan(abs(dy_min) / abs(dx_min))
    if dx_min > 0:
        if dy_min >= 0:
            angle1 = angle_abs
            angle2 = angle_abs + math.pi
        else:
            angle1 = -angle_abs
            angle2 = -angle_abs - math.pi
    elif dx_min < 0:
        if dy_min >= 0:
            angle1 = math.pi - angle_abs
            angle2 = -angle_abs
        else:
            angle1 = angle_abs + math.pi
            angle2 = angle_abs

    # rotate axes accordingly to calculate finter and ftrans for each particle
    finter1 = fx1 * math.cos(angle1) + fy1 * math.sin(angle1)
    ftrans1 = -fx1 * math.sin(angle1) + fy1 * math.cos(angle1)

    finter2 = fx2 * math.cos(angle2) + fy2 * math.sin(angle2)
    ftrans2 = -fx2 * math.sin(angle2) + fy2 * math.cos(angle2)

    # add the forces to find total finter and ftrans
    finter = (finter1 + finter2) / 2
    ftrans = (ftrans1 + ftrans2) / 2

    return [finter, ftrans]
